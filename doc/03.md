## `Ctrl-Q`を押したら終了するようにする

```c
#define CTRL_KEY(k) ((k) & 0x1f)

/* ... */

int main() { enableRawMode();

  while(1) {
    char c = '\0';
    if (read(STDIN_FILENO, &c, 1) == -1 && errno != EAGAIN) die("read");
    if (iscntrl(c)) {
      printf("%d\r\n", c);
    } else {
      printf("%d ('%c')\r\n", c, c);
    }
    if (c == CTRL_KEY('q')) break;
  }
  return 0;
}
```

`CTRL_KEY`マクロは文字と`00011111`とのビット毎AND演算を行う。別の言葉で言うと、これは文字の上位3ビットを`0`にセットしている。ビット毎AND演算の意味は、`Ctrl`と組み合わせた文字キーを押すと、文字コードから`2^6`の部分を削除した値が送られることに相当する。

## キーボード入力のリファクタリング

```diff
+char editorReadKey() {
+  int nread;
+  char c;
+  while((nread = read(STDIN_FILENO, &c, 1)) != 1) {
+    if (nread == -1 && errno != EAGAIN) die("read");
+  }
+  return c;
+}
+
+void editorProcessKeyPress() {
+  char c = editorReadKey();
+
+  switch(c) {
+    case CTRL_KEY('q'):
+      exit(0);
+      break;
+  }
+}
+
int main() {
  enableRawMode();

  while(1) {
-    char c = '\0';
-    if (read(STDIN_FILENO, &c, 1) == -1 && errno != EAGAIN) die("read");
-    if (iscntrl(c)) {
-      printf("%d\r\n", c);
-    } else {
-      printf("%d ('%c')\r\n", c, c);
-    }
-    if (c == CTRL_KEY('q')) break;
+    editorProcessKeyPress();
  }
  return 0;
}
```

`editorReadKey()`はキー入力を待ち、入力値を返す。あとでこの関数はエスケープシーケンスを扱うように変更する。

`editorProcessKeyPress()`は得られたキー入力を処理する。ここで文字列の挿入処理や、`Ctrl`キーとの組み合わせによるエディタの機能を作り込んでいく。

## スクリーンの消去

この実装では、編集中の画面をキー入力毎に毎回描画する。まずスクリーンを消去するところから始めよう。

```c
void editorRefreshScreen() {
  write(STDOUT_FILENO, "\x1b[2J", 4);
}

/* ... */

int main() {
  enableRawMode();

  while(1) {
    editorRefreshScreen();
    editorProcessKeyPress();
  }
  return 0;
}
```

`write`は`<unistd.h>`から来ている。

`write`の3番目の引数`4`はターミナルに書き込むバイト数を表している。最初の1バイト、`\xb1`がエスケープ文字で十進数では`27`, 残りの3バイトが`[2J`である。

このコードはターミナルにエスケープシーケンスを書き込んでいる。エスケープシーケンスはエスケープ文字`27`から始まり、`[`がそれに続く。これはターミナルに様々なテキスト整形（色付け、カーソル移動、スクリーンの部分的消去）を行わせている。

ここではスクリーンを消去するのに`J`コマンド（[画面内消去](http://vt100.net/docs/vt100-ug/chapter3.html#ED)）を使っている。エスケープシーケンスは引数を取る。`2`はスクリーン全体を消去することを意味する。

このテキストエディタの実装を通じて、[VT100](https://en.wikipedia.org/wiki/VT100)エスケープシーケンスを多用する。これは現代的なターミナルエミュレータでは広くサポートされているものだ。完全なガイドは[VT100 User Guide](http://vt100.net/docs/vt100-ug/chapter3.html)を参照。

可能な限り多くのターミナルをサポートしたいときは、[ncurses](https://en.wikipedia.org/wiki/Ncurses)ライブラリを使うとよいだろう。これは[terminfo](https://en.wikipedia.org/wiki/Terminfo)というデータベースを元に特定のターミナル毎のサポートを行なっている。

## カーソルの再配置

気づいたかもしれないが、`<esc>[2J`コマンドを送ると、カーソルは画面下に置き去りになる。このカーソルを一番左上に戻したい。

```diff
void editorRefreshScreen() {
  write(STDOUT_FILENO, "\x1b[2J", 4);
+ write(STDOUT_FILENO, "\x1b[H", 3);
}
```

このエスケープシーケンスは`3`バイト長である。コマンドは`H`([カーソル位置](http://vt100.net/docs/vt100-ug/chapter3.html#CUP))であり、カーソルの位置を決める。`H`コマンドは、実際には行と列の2つの引数を取る(例`<esc>[12;40H`, 複数のパラーメータを取るときは`;`で区切る)。しかし、引数を与えなかったときはデフォルト引数が両方`1`となっている。よって、引数を省略するとカーソルは一番左上に来ることになる。（ちなみに行と列の番号は`0`ではなく`1`から始まる）。

## 終了時のスクリーン消去

プログラムが終了するときにも、画面をクリアしカーソルを再配置しよう。急にプログラムが終了すると、画面に描画途中のゴミが大量に残ることになる。`die()`が呼び出された場合と`Ctrl-q`が押された場合を考えて、前節までの処理を加える。

```diff
void die(const char *s) {
+ write(STDOUT_FILENO, "\x1b[2J", 4);
+ write(STDOUT_FILENO, "\x1b[H", 3);

  perror(s);
  exit(1);
}

/* ... */

void editorProcessKeypress() {
  char c = editorReadKey();

  switch (c) {
    case CTRL_KEY('q'):
+     write(STDOUT_FILENO, "\x1b[2J", 4);
+     write(STDOUT_FILENO, "\x1b[H", 3);
      exit(0);
      break;
  }
}
```

プログラム終了時、画面を消すのに`atexit()`を使えると思うかもしれない。しかし`die()`が表示したメッセージをも消してしまうのでここでは使わない。

## チルダ

いよいよ描画を始めよう。まずここでは、[vim](http://www.vim.org/)風にスクリーンの左端列をチルダで埋めることをしてみる。

```diff
+void editorDrawRows() {
+  int y;
+  for (y = 0; y < 24; y++) {
+    write(STDOUT_FILENO, "~\r\n", 3);
+  }
+}


void editorRefreshScreen() {
  write(STDOUT_FILENO, "\x1b[2J", 4);
  write(STDOUT_FILENO, "\x1b[H", 3);

+ editorDrawRows();

+ write(STDOUT_FILENO, "\x1b[H", 3);
}
```

`editorDrawRows()`は編集中テキストのバッファの各行の描画を受け持つ。

ターミナルのサイズがまだ分からないので、さしあたり`24`行描画を行なっている。

描画が終わったらエスケープシーケンス`<esc>[H`によりカーソルを左上に戻している。

## グローバルな状態を持つ構造体

次の目的はターミナルの大きさを手に入れることである。その前に、エディターの状態を保持するグローバルな構造体を定義したい。この構造体はターミナルの幅と高さを保持する。ただ今のところは`termios`構造体だけを置いておこう。

```c
struct editorConfig {
  struct termios orig_termios;
};

struct editorConfig E;
```

```diff
void disableRawMode() {
+ if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &E.orig_termios) == -1)
    die("tcsetattr");
}

void enableRawMode() {
+ if (tcgetattr(STDIN_FILENO, &E.orig_termios) == -1) die("tcgetattr");
  atexit(disableRawMode);

+ struct termios raw = E.orig_termios;
  raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
  raw.c_oflag &= ~(OPOST);
  raw.c_cflag |= (CS8);
  raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
  raw.c_cc[VMIN] = 0;
  raw.c_cc[VTIME] = 1;

  if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw) == -1) die("tcsetattr");
}
```

エディタの状態を含むグローバル変数をここでは`E`と名付けた。そして`orig_termios`を`E.orig_termios`に置き換えた。

## ウィンドウサイズを得る（簡易に）

たいていのシステムでは、ターミナルの大きさは`ioctl()`関数から`TIOCGWINSZ`をリクエストすることにより取得できる。(私が聞きおよぶ限りでは、`TIOCGWINSZ`は**T**erminal **I**nput **O**utput **C**on**t**ro**l** **G**et **WIN**dow **S**i**Z**eの略である）

```c
#include <sys/ioctl.h>

/* ... */

int getWindowSize(int *rows, int *cols) {
  struct winsize ws;
  if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == -1 || ws.ws_col == 0) {
    return -1;
  } else {
    *cols = ws.ws_col;
    *rows = ws.ws_row;
    return 0;
  }
}
```

`ioctl()`, `TIOCGWINSZ`, `struct winsize`は`<sys/ioctl.h>`から来ている。

`ioctl()`が成功すると、与えられた`winsize`構造体にターミナルのタテ幅とヨコ幅の情報が書き込まれる。失敗時に`ioctl()`は`-1`を返す。返された値が0である場合も明らかにエラーと思われるので、`ws.ws_col`をチェックしておく。`ioctl()`がいずれかのチェックに失敗すると、`getWindowSize()`は`-1`を返し失敗を報告する。

`ioctl()`が成功したら、関数に与えられた`int`型のポインタ引数2つに値を書き込む。（これは複数の変値をもつ関数を書きたいとき、C言語が使う常套手段である）

グローバルなエディタの状態を表す`editorConfig`に、メンバ`screenrows`と`screencols`を加えよう。

```diff
struct editorConfig {
+ int screenrows;
+ int screencols;
  struct termios orig_termios;
};

struct editorConfig E;

/* ... */

+void initEditor() {
+  if (getWindowSize(&E.screenrows, &E.screencols) == -1) die("getWindowSize");
+}

int main() {
  enableRawMode();
+ initEditor();
  while (1) {
    editorRefreshScreen();
    editorProcessKeypress();
  }
  return 0;
}
```

`initEditor()`の仕事は`E`構造体のフィールドを初期化することである。

これで適切な数のチルダを表示できるようになった。

```c
void editorDrawRows() {
  int y;
+ for (y = 0; y < E.screenrows; y++) {
    write(STDOUT_FILENO, "~\r\n", 3);
  }
}
```

