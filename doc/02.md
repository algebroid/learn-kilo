## Rawモードに入る

キー入力をユーザーから受け取り、何もしないプログラムを作る。

```c
#include <unistd.h>
int main() {
  char c;
  while (read(STDIN_FILENO, &c, 1) == 1);
  return 0;
}
```

`read()`と`STDIN_FILENO`は`<unistd.h>`から来ている。`read`は標準入力から1バイト読み込み、変数`c`に値を書き込む。

ここで、ターミナルでエディタを作るのに必要な知識を確認する。それはターミナルの**カノニカルモード**である。カノニカルモード、あるいは**cookedモード**では、キーボードから入力した文字は、Enterを押さないとプログラムに送ることはできない。これは簡単なプログラムを作る上では重宝する。しかし、エディタのようにキーボードからの入力をすぐに反映したい場合は不便である。

そこで必要なのが**rawモード**である。しかし残念ながら、ターミナルをrawモードに設定する簡単な方法はない。ターミナルの中のいろんなフラグをバキバキに折る必要があり、手間がかかるのだ。本章ではこれについて説明する。

上のプログラムは無限ループである。`read()`に`Ctrl+D`でシグナルを送ると、ループ判定を抜けて終了する。`Ctrl+C`を入力すると、判定に関係なく即座に終了する。

## `q`を押して終了？

この節は、`q`キーを受け取ると終了するようにプログラムを変更する。これはカノニカルモードを説明するという意図がある。

```diff
#include <unistd.h>

int main() {
  char c;
+ while (read(STDIN_FILENO, &c, 1) == 1 && c != 'q');
  return 0;
}
```

このプログラムを終了するにはqを押し、Enterする必要がある。`read`は一度に１文字ずつ字を読み込み、qを読むと`while`を抜け出して終了する。qの後に残った文字は入力キュー中に残され、プログラムが終了したあとシェルに表示sれる。

## エコーを止める

1. `tcgetattr()`で現在のターミナル属性を構造体に読み取る。
2. `termios`構造体を変更する。
3. `tcsetattr()`で新しいターミナル属性を書き込む。

2番目でやっていることは`ECHO`属性のオフである。

```diffc
+ #include <termios.h>
#include <unistd.h>

+ void enableRawMode() {
+   struct termios raw;
+   tcgetattr(STDIN_FILENO, &raw);
+   raw.c_lflag &= ~(ECHO);
+   tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw);
+ }

int main() {
+ enableRawMode();
  char c;
  while (read(STDIN_FILENO, &c, 1) == 1 && c != 'q');
  return 0;
}
```

`struct termios`, `tcgetattr()`, `tcsetattr()`, `ECHO`と`TCSAFLUSH`はすべて`<termios.h>`から来ている。

`ECHO`属性は、キーボードの入力をターミナルに表示するかどうか、というところを受け持っている。これはrawモードでは邪魔になる。エコーを止めるのは、例えば`sudo`で実行されたコマンドのパスワード入力などでお馴染みである。

これはターミナルによるが、プログラムを終了すると入力した文字が未だにエコーされている場合がある。これは心配無用で、`Ctrl-c`を入力することでシェルへの新しい入力を行えるようになる。それから`reset`とタイプしてEnterすれば（たいていの場合）シェルは正常に戻る。もしダメな場合は、ターミナルエミュレータを再起動してもらいたい。次のステップでこれらの問題は修正する。

ターミナル属性は`tcgetattr()`を通じて`termios`構造体に読み込まれる。その構造体を変更してから、`tcsetattr()`でターミナルに設定を反映する。引数`TCSAFLUSH`はいつ変更を適用するかについてを決めている。このケースでは、すべての保留中の出力が端末に書き込まれるのを待ち、また読み込まれていない全ての入力を破棄する。

`c_lflag`は"local flag"のことである。これは雑多な状態を管理している。他のフラグには`c_iflag`（入力フラグ）、`c_oflag`（出力フラグ）、`c_cflag`（コントロールフラグ）がある。それぞれrawモードを使う上では変更する必要があるので記憶の端に留めておいて欲しい。

`ECHO`は[ビットフラグ](https://en.wikipedia.org/wiki/Bit_field)である。バイナリ値で`0000000000000000000000000001000`と定義されている。コードではビット毎NOT演算`~`により値が反転するので、`11111111111111111111111111110111`を得ており、これをビット毎AND演算によりフラグにセットしているので、右から4番目のビットが`0`にセットされることになり、他はそのままの値になる。これでエコーをオフにする設定をしたことになっている。

## 終了時にrawモードを無効化する

元のターミナル属性を保存しておき、プログラムが終了した時は元に戻したい。`termios`構造体のコピーを取っておき、プログラム終了時に`tcsetattr()`を適用するのがよいだろう。

```c
#include <stdlib.h>
#include <termios.h>
#include <unistd.h>

struct termios orig_termios;

void disableRawMode() {
  tcsetattr(STDIN_FILENO, TCSAFLUSH, &orig_termios);
}

void enableRawMode() {
  struct termios raw = orig_termios;
  atexit(disableRawMode);

  tcgetattr(STDIN_FILENO, &raw);
  raw.c_lflag &= ~(ECHO);
  tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw);
}
```

`atexit()`は`<stdlib.h>`にある関数で、`disableRawMode()`関数を登録し、プログラムが終了する際（`main`から`return`する場合または`exit()`を呼び出す場合）に、自動的にそれを呼び出す。この方法で、プログラムが終了する際にターミナル属性を元に戻すことができる。

元のターミナル属性をグローバル変数`orig_termios`に保持する。`orig_termios`を`raw`に割り当てるときはコピーを取っている。

前述のように、`tcsetattr()`を`TCSAFLUSH`で呼び出すと読み込まれていない入力を破棄する。よって余計な表示が行われなくなる。（ただしCygwinではうまくいかないらしい）
