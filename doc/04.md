## 行ビューアー

テキスト行を保持するデータ型を作ろう。

```diff
+typedef struct erow {
+  int size;
+  char *chars;
+} erow;

struct editorConfig {
  int cx, cy;
  int screenrows;
  int screencols;
+ int numrows;
+ erow row;
  struct termios orig_termios;
};

/* ... */

void initEditor() {
  E.cx = 0;
  E.cy = 0;
+ E.numrows = 0;

  if (getWindowSize(&E.screenrows, &E.screencols) == -1) die("getWindowSize");
}
```

`erow`は"editor row"（エディタ行）を表す。この構造体は、動的に割り当てられた文字データとしてテキスト行およびその長さを保持する。`typedef`により、`struct erow`の代わりに`erow`で構造体を参照できるようにしている。

我々は`erow`および`enumrows`変数をエディタのグローバル状態に加えている。今のところ、エディタはテキストの1行目しか表示しない。よって`numrows`は値`0`または`1`しか取りえない。`initEditor()`中では`numrows`を`0`で初期化している。

`erow`をなんらかのテキストで埋めてやろう。まだファイル読み込みについては考えたくないので、ハードコードされた`"Hello, world"`文字列を表示することを目指そう。

```diff
+#include <sys/types.h>

/* ... */

void editorOpen() {
  char *line = "Hello, world!";
  ssize_t linelen = 13;

  E.row.size = linelen;
  E.row.chars = malloc(linelen + 1);
  memcpy(E.row.chars, line, linelen);
  E.row.chars[linelen] = '\0';
  E.numrows = 1;
}

/* ... */

int main() {
  enableRawMode();
  initEditor();
  editorOpen();

  while (1) {
    editorRefreshScreen();
    editorProcessKeypress();
  }

  return 0;
}
```

`malloc()`は`<stdlib.h>`から、`ssize_t`は`<sys/types.h>`から来ている。

`editorOpen()`は最終的にはディスクからファイルを読み取る関数にすることを目標としている。"Hello, world"というメッセージを`erow`構造体にロードするために、メッセージの長さを`size`にセットし、`malloc()`で必要なメモリを確保し、`memcpy()`で確保された`chars`フィールドにメッセージをコピーする。最後に`E.numrows`を`1`にセットして関数を終えている。これは`erow`に表示すべき文字が入っていることを示している。

それでは表示してみよう。

```diff

void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
+   if (y >= E.numrows) {
      if (y == E.screenrows / 3) {
        char welcome[80];
        int welcomelen = snprintf(welcome, sizeof(welcome),
          "Kilo editor -- version %s", KILO_VERSION);
        if (welcomelen > E.screencols) welcomelen = E.screencols;
        int padding = (E.screencols - welcomelen) / 2;
        if (padding) {
          abAppend(ab, "~", 1);
          padding--;
        }
        while (padding--) abAppend(ab, " ", 1);
        abAppend(ab, welcome, welcomelen);
      } else {
        abAppend(ab, "~", 1);
      }
+   } else {
+     int len = E.row.size;
+     if (len > E.screencols) len = E.screencols;
+     abAppend(ab, E.row.chars, len);
+   }

    abAppend(ab, "\x1b[K", 3);
    if (y < E.screenrows - 1) {
      abAppend(ab, "\r\n", 2);
    }
  }
}
```

ここでは以前の行描画コードを新たな`if`文で包んでいる。テキストバッファの部分行を描画しているか、テキストバッファが終わった後の行を描画しているかを判断している。

テキストバッファの部分行を描画するために、ここでは単純に`erow`の`chars`フィールドを書き出している。ただし、文字数が画面の右端を過ぎた場合に、それを切り詰めるように注意する。

次に、ユーザーがファイルを開けるようにしよう。ファイルの1行目を読み込んで表示するプログラムを示す。


```diff
+void editorOpen(char *filename) {
+  FILE *fp = fopen(filename, "r");
+  if (!fp) die("fopen");

+  char *line = NULL;
+  size_t linecap = 0;
+  ssize_t linelen;
+  linelen = getline(&line, &linecap, fp);
+  if (linelen != -1) {
+    while (linelen > 0 && (line[linelen - 1] == '\n' ||
+                           line[linelen - 1] == '\r'))
+      linelen--;
    E.row.size = linelen;
    E.row.chars = malloc(linelen + 1);
    memcpy(E.row.chars, line, linelen);
    E.row.chars[linelen] = '\0';
    E.numrows = 1;
+  }
+  free(line);
+  fclose(fp);
+}

/* ... */

+int main(int argc, char *argv[]) {
  enableRawMode();
  initEditor();
+  if (argc >= 2) {
+    editorOpen(argv[1]);
+  }

  while (1) {
    editorRefreshScreen();
    editorProcessKeypress();
  }

  return 0;
}
```

`FILE`, `fopen()`, `getline()`は`<stdio.h>`から来ている。

`editorOpen()`の核となる部分は変わっていない。ハードコードされた`"Hello, world"`の代わりに、`getline()`で`line`文字列と`linelen`の値を得ている。

`editorOpen()`は引数としてファイル名を取り、`fopen()`でファイルを開いている。ユーザーには、ファイル名をコマンドライン引数から与えることにより使えるようにしている。もし引数が与えられたら、`editorOpen()`を呼び出す。引数なしで`./kilo`が起動されたときは、`editorOpen()`は呼ばれず空ファイルで開始される。

`getline()`はそれぞれの行にいくらメモリを割り当てたらいいか分からないとき、ファイルから行を読み込むのに便利である。この関数はメモリ管理を引き受けてくれる。まず、関数にnullの`line`ポインタと`0`の`lincap`(line capacity)を渡す。この呼び出しで、`getline()`が読み込んだ次の行に新しくメモリを割り当て、`line`がメモリを指し示すよう変更し、`linecap`の値を設定して、どれくらいメモリが割り当てられたかを知らせる。

`getline()`の返り値はそれが読み込んだ行の長さか、あるいはファイル終端で、それ以上読み込める行がないときは`-1`を返す。あとで`editorOpen()`を複数行読み込めるように変更する。そこでは新しい`line`と`linecap`の値を何度も`getline()`に送り返す。`getline()`は`linecap`の値が次に読み込んだ行に収めるのに十分大きい限り、`line`が指すメモリを再利用しようと試みる。この時点では、単に1行をコピーして`E.row.chars`に読み込み、それから`getline()`で割り当てられた`line`を`free()`する。

次に、行末の改行文字とキャリッジリターンを取り除いてから`erow`に文字列をコピーする。それぞれの`erow`は1行のテキストを表しているのが分かっているので、文字列の末尾に改行文字を保持する必要がないのである。

もしコンパイラが`getline()`を使うことについて不平を述べた場合、[`機能検査マクロ`](https://www.gnu.org/software/libc/manual/html_node/Feature-Test-Macros.html)をdefineする必要があるかもしれない。もしあなたのマシンでは問題がなかったとしても、コードの可搬性を上げるために以下のマクロを追加しておこう。

```c
#define _DEFAULT_SOURCE
#define _BSD_SOURCE
#define _GNU_SOURCE
```

これはinclude文の上に追加する。includeするヘッダファイルが、マクロを見て使えるようにする機能を決定するからである。

簡単なバグを修正しよう。歓迎メッセージはユーザーが引数なしでプログラムを開始したときだけ表示したいので、ファイルを開いたときは表示したくない。

```diff
void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    if (y >= E.numrows) {
+     if (E.numrows == 0 && y == E.screenrows / 3) {
        char welcome[80];
        int welcomelen = snprintf(welcome, sizeof(welcome),
          "Kilo editor -- version %s", KILO_VERSION);
        if (welcomelen > E.screencols) welcomelen = E.screencols;
        int padding = (E.screencols - welcomelen) / 2;
        if (padding) {
          abAppend(ab, "~", 1);
          padding--;
        }
        while (padding--) abAppend(ab, " ", 1);
        abAppend(ab, welcome, welcomelen);
      } else {
        abAppend(ab, "~", 1);
      }
    } else {
      int len = E.row.size;
      if (len > E.screencols) len = E.screencols;
      abAppend(ab, E.row.chars, len);
    }

    abAppend(ab, "\x1b[K", 3);
    if (y < E.screenrows - 1) {
      abAppend(ab, "\r\n", 2);
    }
  }
}
```

これで歓迎メッセージは、テキストバッファが完全に空の場合のみ表示されるようになった。

## 複数行を表示する

複数行を保持するために、`E.row`を`erow`構造体の配列にしよう。これは動的割付けされた配列になるので、`erow`へのポインタとし、`NULL`で初期化する（既存の変数に変更を加えるので、これはコードの多くを意図せず壊すことになる。コンパイルは通らない）。

```diff
struct editorConfig {
  int cx, cy;
  int screenrows;
  int screencols;
  int numrows;
+ erow *row;
  struct termios orig_termios;
};

/* ... */

void initEditor() {
  E.cx = 0;
  E.cy = 0;
  E.numrows = 0;
+ E.row = NULL;

  if (getWindowSize(&E.screenrows, &E.screencols) == -1) die("getWindowSize");
}
```

次に、`editorOpen()`中の`E.row`を初期化している部分を、新しい関数`editorAppendRow()`として切り出す。

```c
void editorAppendRow(char *s, size_t len) {
  E.row.size = len;
  E.row.chars = malloc(len + 1);
  memcpy(E.row.chars, s, len);
  E.row.chars[len] = '\0';
  E.numrows = 1;
}
```

```diff
void editorOpen(char *filename) {
  FILE *fp = fopen(filename, "r");
  if (!fp) die("fopen");
  char *line = NULL;
  size_t linecap = 0;
  ssize_t linelen;
  linelen = getline(&line, &linecap, fp);
  if (linelen != -1) {
    while (linelen > 0 && (line[linelen - 1] == '\n' ||
                           line[linelen - 1] == '\r'))
      linelen--;
+   editorAppendRow(line, linelen);
  }
  free(line);
  fclose(fp);
}
```

注意する点は、`line`と`linelen`変数を`s`と`len`にリネームした点である。これは`editorAppendRow()`の引数となっている。

次に、`editorAppendRow()`を新しい`erow`のためメモリ空間を割り当て、与えられた文字列を`E.row`配列の最後の`erow`にコピーするよう変更する。

```diff
void editorAppendRow(char *s, size_t len) {
+ E.row = realloc(E.row, sizeof(erow) * (E.numrows + 1));

+ int at = E.numrows;
+ E.row[at].size = len;
+ E.row[at].chars = malloc(len + 1);
+ memcpy(E.row[at].chars, s, len);
+ E.row[at].chars[len] = '\0';
+ E.numrows++;
}
```

まず`realloc()`に何バイト割り当てたいのかを知らせる必要がある。これはそれぞれの`erow`が取るバイト数(`sizeof(erow)`)に行数を乗じている。`at`は初期化する新しい行の添え字を示している。`E.row`をすべて`E.row[at]`で置き換えている。最後に、`E.numrows`をインクリメントして処理を終えている。

次に、現在行を表示するために、`editorDrawRows()`を`E.row`ではなく`E.row[y]`を使うよう変更する。

```diff
void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    if (y >= E.numrows) {
      if (E.numrows == 0 && y == E.screenrows / 3) {
        char welcome[80];
        int welcomelen = snprintf(welcome, sizeof(welcome),
          "Kilo editor -- version %s", KILO_VERSION);
        if (welcomelen > E.screencols) welcomelen = E.screencols;
        int padding = (E.screencols - welcomelen) / 2;
        if (padding) {
          abAppend(ab, "~", 1);
          padding--;
        }
        while (padding--) abAppend(ab, " ", 1);
        abAppend(ab, welcome, welcomelen);
      } else {
        abAppend(ab, "~", 1);
      }
    } else {
+     int len = E.row[y].size;
      if (len > E.screencols) len = E.screencols;
+     abAppend(ab, E.row[y].chars, len);
    }

    abAppend(ab, "\x1b[K", 3);
    if (y < E.screenrows - 1) {
      abAppend(ab, "\r\n", 2);
    }
  }
}
```

これでコードのコンパイルが通るようになったが、このままだとまだファイルから1行しか読み出すことができない。`editorOpen()`をファイル全体を読み出すように変更する。

```diff
void editorOpen(char *filename) {
  FILE *fp = fopen(filename, "r");
  if (!fp) die("fopen");
  char *line = NULL;
  size_t linecap = 0;
  ssize_t linelen;
+ while ((linelen = getline(&line, &linecap, fp)) != -1) {
    while (linelen > 0 && (line[linelen - 1] == '\n' ||
                           line[linelen - 1] == '\r'))
      linelen--;
    editorAppendRow(line, linelen);
  }
  free(line);
  fclose(fp);
}
```

`while`ループは`getline()`が`-1`を返したとき、すなわちファイル終端に達したときループを抜けるので正しく動作する。

`./kilo kilo.c`を実行してみよう。画面全体がテキスト行で満たされているはずだ。

## 垂直スクロール

次に、画面をスクロールして、ユーザーにファイル全体を閲覧できるようにしたい。`rowoff` (row offset) 変数をグローバルなエディタの状態に加えて、ユーザーが何行目までスクロールしたのか把握するようにしよう。


```diff
struct editorConfig {
  int cx, cy;
+ int rowoff;
  int screenrows;
  int screencols;
  int numrows;
  erow *row;
  struct termios orig_termios;
};

/* ... */

void initEditor() {
  E.cx = 0;
  E.cy = 0;
+ E.rowoff = 0;
  E.numrows = 0;
  E.row = NULL;
  if (getWindowSize(&E.screenrows, &E.screencols) == -1) die("getWindowSize");
}
```

`rowoff`は`0`で初期化している。これはファイル先頭にスクロールしていることを意味する。

さて、`editorDrawRows()`に`rowoff`の値に応じ、正しい範囲の行を描画させるようにしよう。


```diff
void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
+   int filerow = y + E.rowoff;
+   if (filerow >= E.numrows) {
      if (E.numrows == 0 && y == E.screenrows / 3) {
        char welcome[80];
        int welcomelen = snprintf(welcome, sizeof(welcome),
          "Kilo editor -- version %s", KILO_VERSION);
        if (welcomelen > E.screencols) welcomelen = E.screencols;
        int padding = (E.screencols - welcomelen) / 2;
        if (padding) {
          abAppend(ab, "~", 1);
          padding--;
        }
        while (padding--) abAppend(ab, " ", 1);
        abAppend(ab, welcome, welcomelen);
      } else {
        abAppend(ab, "~", 1);
      }
    } else {
+     int len = E.row[filerow].size;
      if (len > E.screencols) len = E.screencols;
+     abAppend(ab, E.row[filerow].chars, len);
    }
    abAppend(ab, "\x1b[K", 3);
    if (y < E.screenrows - 1) {
      abAppend(ab, "\r\n", 2);
    }
  }
}
```

それぞれの`y`に`E.rowoff`を加えて、現在行以降のファイル行を表示している。これを`filerow`という新しい変数に格納し、`E.row`のインデックスとしている。

どのタイミングで`E.rowoff`を更新するべきだろうか？ ここでのやり方は、カーソルがウィンドウの外側へ移動したときに`E.rowoff`を更新することである。その場合`E.rowoff`をウィンドウの内側に来るように調整する。このロジックを`editorScroll()`という関数で実装し、スクリーンがリフレッシュされる前に呼び出すことにしよう。

```c
void editorScroll() {
  if (E.cy < E.rowoff) {
    E.rowoff = E.cy;
  }
  if (E.cy >= E.rowoff + E.screenrows) {
    E.rowoff = E.cy - E.screenrows + 1;
  }
}

/* ... */

void editorRefreshScreen() {
  editorScroll();
  /* ... */
}
```

最初の`if`文は、カーソルがウィンドウの上に抜けているかを調べている。もしそうなら、カーソルの位置に上移動する。2つめの`if`はカーソルが下に抜けているか調べている。これは1つめより少しだけ複雑な式になっている。`E.rowoff`がスクリーンの最上部の位置を参照しているためである。なので`E.screenrow`を加えることでスクリーン最下部を算出できる。

次に、カーソルに画面下移動をできるようにする（ただしファイルの最下部を突き抜けないように注意する）。

```diff
void editorMoveCursor(int key) {
  switch (key) {
    case ARROW_LEFT:
      if (E.cx != 0) {
        E.cx--;
      }
      break;
    case ARROW_RIGHT:
      if (E.cx != E.screencols - 1) {
        E.cx++;
      }
      break;
    case ARROW_UP:
      if (E.cy != 0) {
        E.cy--;
      }
      break;
    case ARROW_DOWN:
      if (E.cy < E.numrows) {
+       E.cy++;
      }
      break;
  }
}
```

`./kilo kilo.c`を実行したとき、ファイルの全体をスクロールできるなっているはずだ。

また、ファイルがタブ文字を含む場合、スクリーンに描画するときタブが使う文字が正しく消去されていないことがわかる。

さて、上向きにスクロールを戻そうとすると、カーソルの位置が正しく描画されないことに気づくだろう。これはスクロールバックする際に、`E.cy`がスクリーン上のカーソル位置をもはや指し示していないことに起因する。`E.cy`はテキストファイル中のカーソル位置を示している。スクリーン上にカーソルを位置付けるために、`E.cy`から`E.rowoff`を引くことにする。

```diff
void editorRefreshScreen() {
  editorScroll();

  struct abuf ab = ABUF_INIT;

  abAppend(&ab, "\x1b[?25l", 6);
  abAppend(&ab, "\x1b[H", 3);

  editorDrawRows(&ab);

  char buf[32];
+ snprintf(buf, sizeof(buf), "\x1b[%d;%dH", (E.cy - E.rowoff) + 1, E.cx + 1);
  abAppend(&ab, buf, strlen(buf));

  abAppend(&ab, "\x1b[?25h", 6);

  write(STDOUT_FILENO, ab.b, ab.len);
  abFree(&ab);
}
```

## 水平スクロール

水平スクロールに取り掛かろう。これは垂直スクロールの実装とだいたい同じである。グローバルなエディタの状態に`coloff`（列オフセット）変数を追加するところから始めよう。

```diff
struct editorConfig {
  int cx, cy;
  int rowoff;
+ int coloff;
  int screenrows;
  int screencols;
  int numrows;
  erow *row;
  struct termios orig_termios;
};

/* ... */

void initEditor() {
  E.cx = 0;
  E.cy = 0;
  E.rowoff = 0;
+ E.coloff = 0;
  E.numrows = 0;
  E.row = NULL;
  if (getWindowSize(&E.screenrows, &E.screencols) == -1) die("getWindowSize");
}
```

列オフセットのもとでそれぞれの行を表示するために、各`erow`の`chars`のインデックスとして`E.coloff`を使い、行長からオフセット長を引くことにする。

```diff
void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    int filerow = y + E.rowoff;
    if (filerow >= E.numrows) {
      if (E.numrows == 0 && y == E.screenrows / 3) {
        char welcome[80];
        int welcomelen = snprintf(welcome, sizeof(welcome),
          "Kilo editor -- version %s", KILO_VERSION);
        if (welcomelen > E.screencols) welcomelen = E.screencols;
        int padding = (E.screencols - welcomelen) / 2;
        if (padding) {
          abAppend(ab, "~", 1);
          padding--;
        }
        while (padding--) abAppend(ab, " ", 1);
        abAppend(ab, welcome, welcomelen);
      } else {
        abAppend(ab, "~", 1);
      }
    } else {
+     int len = E.row[filerow].size - E.coloff;
+     if (len < 0) len = 0;
      if (len > E.screencols) len = E.screencols;
+     abAppend(ab, &E.row[filerow].chars[E.coloff], len);
    }
    abAppend(ab, "\x1b[K", 3);
    if (y < E.screenrows - 1) {
      abAppend(ab, "\r\n", 2);
    }
  }
}
```

留意すべきは、文字列長から`E.coloff`を引くとき、`len`が負数になりうることである。これはユーザーが行末を過ぎて水平にスクロールすることを意味する。負になる場合、`len`を`0`としてその行には何も表示されない。

`editorScroll()`に水平スクロールの処理を書き足そう。

```diff
void editorScroll() {
  if (E.cy < E.rowoff) {
    E.rowoff = E.cy;
  }
  if (E.cy >= E.rowoff + E.screenrows) {
    E.rowoff = E.cy - E.screenrows + 1;
  }
+ if (E.cx < E.coloff) {
+   E.coloff = E.cx;
+ }
+ if (E.cx >= E.coloff + E.screencols) {
+   E.coloff = E.cx - E.screencols + 1;
+ }
}
```

見れば分かるが、これはまさに垂直スクロールと同様のコードである。`E.cy`を`E.cx`で、`E.rowoff`を`E.coloff`で、`E.screenrows`を`E.screencols`で置き換えただけだ。

ユーザーにスクリーンの右端を超えてスクロースできるようにしよう。

```
void editorMoveCursor(int key) {
  switch (key) {
    case ARROW_LEFT:
      if (E.cx != 0) {
        E.cx--;
      }
      break;
    case ARROW_RIGHT:
-     if (E.cx != E.screencols - 1) {
      E.cx++;
-     }
      break;
    case ARROW_UP:
      if (E.cy != 0) {
        E.cy--;
      }
      break;
    case ARROW_DOWN:
      if (E.cy < E.numrows) {
        E.cy++;
      }
      break;
  }
}
```

これで水平スクロールが動作することが分かるはずである。

次に、垂直スクロールの時と同様に、カーソル位置を修正しよう。

```diff
void editorRefreshScreen() {
  editorScroll();

  struct abuf ab = ABUF_INIT;

  abAppend(&ab, "\x1b[?25l", 6);
  abAppend(&ab, "\x1b[H", 3);

  editorDrawRows(&ab);
  char buf[32];
+ snprintf(buf, sizeof(buf), "\x1b[%d;%dH", (E.cy - E.rowoff) + 1,
+                                           (E.cx - E.coloff) + 1);
  abAppend(&ab, buf, strlen(buf));

  abAppend(&ab, "\x1b[?25h", 6);

  write(STDOUT_FILENO, ab.b, ab.len);
  abFree(&ab);
}
```

## 右へのスクロールを制限する

いま、`E.cx`と`E.cy`の両方が、ファイル内のカーソル位置を参照している。これはスクリーン上の位置を参照していない。次の数ステップでは、`E.cx`と`E.cy`を、ファイル上の正しい位置に制限することを目標とする。このままだと、ユーザーはカーソルを行の右側を超えた場所で、テキストの挿入を始めることができるが、これにはあまり意味がない。

現在の行末を超えてスクロールできないようにするところから始めよう。

```diff
void editorMoveCursor(int key) {
+ erow *row = (E.cy >= E.numrows) ? NULL : &E.row[E.cy];

  switch (key) {
    case ARROW_LEFT:
      if (E.cx != 0) {
        E.cx--;
      }
      break;
    case ARROW_RIGHT:
+     if (row && E.cx < row->size) {
        E.cx++;
+     }
      break;
    case ARROW_UP:
      if (E.cy != 0) {
        E.cy--;
      }
      break;
    case ARROW_DOWN:
      if (E.cy < E.numrows) {
        E.cy++;
      }
      break;
  }
}
```

`E.cy`はファイルの最終行を超過している可能性があるので、三項演算子でカーソルが存在する行の上にあるか調べる。もし存在するなら、`row`変数はカーソルが乗っている`erow`を指し示すようにし、カーソルが右に移動する前に`E.cx`が行末にあるかどうかをチェックする。

## 行末でカーソルを折り返す

前節の修正にも関わらず、ユーザーにはまだ行末を超えてカーソルを移動する手段が残されている。長い行の行末に移動し、それからより短い行に下移動した場合である。この場合、`E.cx`の値は変わらない。そしてカーソルは現在の行末を超えて右側に移動してしまう。

`editorMoveCursor()`に修正を加えて、`E.cx`が現在の行末を超えないようにしよう。

```diff
void editorMoveCursor(int key) {
  erow *row = (E.cy >= E.numrows) ? NULL : &E.row[E.cy];
  switch (key) {
    case ARROW_LEFT:
      if (E.cx != 0) {
        E.cx--;
      }
      break;
    case ARROW_RIGHT:
      if (row && E.cx < row->size) {
        E.cx++;
      }
      break;
    case ARROW_UP:
      if (E.cy != 0) {
        E.cy--;
      }
      break;
    case ARROW_DOWN:
      if (E.cy < E.numrows) {
        E.cy++;
      }
      break;
  }
+ row = (E.cy >= E.numrows) ? NULL : &E.row[E.cy];
+ int rowlen = row ? row->size : 0;
+ if (E.cx > rowlen) {
+   E.cx = rowlen;
+ }
}
```

`E.cy`は先ほどまでと異なる行を指している可能性があるので、ここでは`row`を設定しなおしている。さらに現在の行末を`E.cx`が超えているかを判定し、値を設定し直している。ここで留意すべきは、`NULL`は長さ`0`の行とみなしていることであるが、これはコードの目的に叶っている。
